### 안정성 뒤에 숨겨진 큰 장점 

- 테스트 코드를 거의 작성하지 않았음 

    - 다르게 말하면, 테스트코드 없음에도 더욱 안전

- 가능했던 이유?

    - `부분 함수`의 사용이 최소화되었기 때문 

### 부분 함수(partial function)란?

- 모든 입력에 대해 출력이 정의되지 않은 함수

    - 보통 함수가 아니라고 배움 

- x: 1,2,3 => y : a,b,c,d

    - 2---> d, 3--->c의 결과를 가리킬 때,

    - 1에 해당하는 결과는 undefined behavior

### 현실의 부분 함수 예시

```javascript
// 1
const inverse = (x) => 1 / x;

// 2
const head = (numbers) => numbers[0];

// 3 
const getName = (person) => person.name;

// 4
const getNameExn = (person) => {

    if(!person) throw "Person can't be null!";
    
    return person.name;
}

```

- 1번의 예시 : 부모에 0이 들어가는 것은 undefined behavior

    - 보통은 0에 대해서 따로 체크 

- 2번의 예시 : 배열의 첫 번째 원소를 가져오는 예시 

    - 배열이 비어있을 경우에는 정의되지 않은 부분 함수 

- 3번의 예시 : person이 null일 경우에 부분 함수

- 4번의 예시 : 정의한 동작임에도 예외를 발생시켜 결과가 없는 부분 함수

### 부분 함수에서 전체 함수로

- rescript는 `type system`을 통해 전체 함수를 달성 

    - 명시적인 부분 함수가 아니면 컴파일 불가능 

- 전체 함수가 되기 위해 필요한 것 

    - null, undefined => `Option 타입`

    - 예외 => `Result 타입`

    - 상태 모델링 => `서로소 합집합 타입`

### 테스트 코드와의 관계

- 테스트 코드는 happy path만 확인하지 않음 

    - unhappy path 테스트로 안정성을 어필 

    - 귀납적인 소프트웨어 검증법 

- 문제는...

    - 모든 unhappy path 파악에 많은 시간과 노력이 듬 

    - 물론 지속적인 관리 비용도..


- 반면 리스크립트는...

    - 실수로 대응을 빠뜨린다면 컴파일 에러 발생 

        - 모든 unhappy path가 고려되었다는 뜻 

        - 두려움 없는 `리팩토링` 

### 우리가 테스트 코드를 작성하는 이유 

1. 문제가 있는지 확인하기 위해 

2. 동료간 신뢰를 보이기 위해 

    - A: "PR 올렸습니다. 리뷰 부탁드려요."
    - B: (바빠서 돌려보진 못했지만) "테스트 잘 통과하네요. LGTM!"

- 책임은 져야 하는데, 바빠서 검사하기 힘들 때 

### 컴파일러가 돌려주는 신뢰의 비용 

- 전체 함수 & 순수 함수로만 작성된 PR

    - 리뷰 부담감이 대폭 감소

    - 테스트 코드도 꼭 필요한 곳에만 요구 

- 확보된 기회비용 => 생산적인 주제에 재투자

    - 설계, 데이터 모델링 리뷰 강화 => 두려움 없는 리팩토링 

### 함수형 언어 정말 좋은가?

- 장점 

    - 전체 함수로 인한 안정성

    - 강력한 원칙들로 인한 효율성 

    - 재미(?????)

- 단점 

    - 학습 비용 

    - ~~성능~~ 

### 모든 상황에서 리스크립트가 답은 아니었습니다.

- 너무 빡빡한 타입 시스템 때문에 ROI가 나오지 않기도...

- 하지만, 함수형 패러다임은 여전히 좋다고 생각합니다 

    - 때문에 함수형이며 동적인 Clojure를 함께 사용하고 있습니다.

[다음 페이지](./explanation3.md)